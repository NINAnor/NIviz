[{"path":"index.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"","code":""},{"path":"downloading-and-preparing-example-data.html","id":"downloading-and-preparing-example-data","chapter":"2 Downloading and preparing example data","heading":"2 Downloading and preparing example data","text":"Fill username (NINA email) password.Choose indicator(s) want, use NIcalc “importDatasetApi” function retrieve data database save dataset locally.Next, need assemble data set. shouldn’t necessary since data already present. One thing notices jerv, distribution familiy parameters appear assembling.Save filesLoading datafiles back R.reference values also bootstrapped uncertainties. coded year = NA. might, however, just end using row means.Save files","code":"\nlibrary(NIcalc)\n\nmyUser <- \"user@nina.no\" # insert NINA email\nmyPwd  <- \"\" # secret password\nindicator <- c(\"Dikesoldogg\",\n               \"Jerv\",\n               \"Elg\",\n               \"Lomvi\",\n               \"Havørn\",\n               \"Lange\")\nfor(i in indicator){\nindicatorImport <- NULL\nindicatorImport <- NIcalc::importDatasetApi(\n  username = myUser,\n  password = myPwd,\n  indic = i,\n  year = c(\"1990\",\"2000\",\"2010\",\"2014\",\"2019\"))\n\nassign(paste0(i, \"_import\"), indicatorImport)\n}\npath <- \"P:/41201612_naturindeks_2021_2023_database_og_innsynslosning/temp/\"\n\nfor(i in indicator){\n  temp <- get(paste0(i, \"_import\"))\n  saveRDS(temp, paste0(path, i, \"_import.rds\"))\n}\n\nfor(i in indicator){\n  temp <- paste0(path, i, \"_import.rds\")\n  assign(i, readRDS(temp))\n}\n# Spesify all of Norway incl the five regions, som NIunits:\nmyNIunits <- c(allArea = T, parts = T, counties = F)\n# Include all BSunits (kommuner) irrespective of the proportion of the main ecosystems:\nmyPartOfTotal <- 0\n\nfor(i in indicator){\n\n  temp <- get(paste0(i, \"_import\"))\n  assemeble <- NULL\n  assemeble <- NIcalc::assembleNiObject(\n    inputData = temp,\n    predefNIunits = myNIunits, \n    partOfTotal = myPartOfTotal, \n    indexType = \"thematic\",\n    part = \"ecosystem\",\n    total = \"total\")  \n  \n  # I dont se the output changing if I for example chose total = marine. Perhaps 'part' and 'total' only becomes an issue if partOfTotal != 0.\n  \n  assign(paste0(i, \"_assemble\"), assemeble)\n\n}\n\nfor(i in indicator){\n  temp <- get(paste0(i, \"_assemble\"))\n  saveRDS(temp, paste0(\"data/\", i, \"_assemebled.rds\"))\n}\nfor(i in indicator){\n  temp <- paste0(\"data/\", i, \"_assemebled.rds\")\n  assign(i, readRDS(temp))\n}\nmyYears <- as.character(c(1990,2000,2010,2014,2019))\n\n\nfor(j in indicator){\nprint(j)\n\n  temp <- get(j)\n  temp2 <- get(paste0(j, \"_import\"))\n  temp_comb <- data.frame(NULL)\n  myMat2 <- NULL\n  myMat2_comb <- NULL\n  obstype <- NULL\n  \n  \n  obstype <- temp$referenceValues$distributionFamilyName\n  obstype[!is.na(obstype)] <- \"tradObs\"\n  obstype[is.na(obstype)]  <- \"customObs\"\n  \nmyMatr <- NIcalc::sampleObsMat(\n  ICunitId           = temp$referenceValues$ICunitId, \n  value              = temp$referenceValues$expectedValue,\n  distrib            = temp$referenceValues$distributionFamilyName,\n  mu                 = temp$referenceValues$distParameter1,\n  sig                = temp$referenceValues$distParameter2,\n  customDistribution = temp$referenceValues$customDistribution,\n  obsType            = obstype,\n  nsim =1000\n        )  \n  \nmyMatr <- as.data.frame(myMatr)\nmyMatr <- myMatr %>%\n  tibble::add_column(.before=1,\n    ICunitID = row.names(myMatr))\n\nmyMatr <- myMatr %>%\n  tibble::add_column(.after = 1,\n      year = NA) \n  \nfor(i in 1:length(myYears)){\nprint(i)\n\nobs <- NULL\n  obs <- temp$indicatorValues[[i]]$distributionFamilyName\n  obs[!is.na(obs)] <- \"tradObs\"\n  obs[is.na(obs)]  <- \"customObs\"\n\n\nmyMat <- NIcalc::sampleObsMat(\n  ICunitId           = temp$indicatorValues[[i]]$ICunitId, \n  value              = temp$indicatorValues[[i]]$expectedValue,\n  distrib            = temp$indicatorValues[[i]]$distributionFamilyName,\n  mu                 = temp$indicatorValues[[i]]$distParameter1,\n  sig                = temp$indicatorValues[[i]]$distParameter2,\n  customDistribution = temp$indicatorValues[[i]]$customDistribution,\n  obsType            = obs,\n  nsim               = 1000\n          \n)\n\n\nmyMat2 <- as.data.frame(myMat)\n\nmyMat2 <- myMat2 %>%\n  tibble::add_column(.before=1,\n    ICunitID = row.names(myMat))\n\nmyMat2 <- myMat2 %>%\n  tibble::add_column(.after = 1,\n    year = myYears[i]) \n\nmyMat2_comb <- rbind(myMat2_comb, myMat2)\n\n }\n\ncomb <- rbind(myMatr, myMat2_comb)\n\ncomb <- comb %>%\n  tibble::add_column(.after = 1,\n    ICunitName = temp2$ICunits$name[match(\n      comb$ICunitID, temp2$ICunits$id)])\n\ncomb2 <- comb[!is.na(comb$year),]\ncomb3 <- comb[is.na(comb$year),]\ncomb3$ref_mean <- rowMeans(comb3[,-c(1:3)])\n\ncombScaled <- comb2 %>%\n  tidyr::pivot_longer(cols = starts_with(\"V\")) \n\ncombScaled <- combScaled %>%\n  tibble::add_column(ref = comb3$ref_mean[\n    match(combScaled$ICunitID, comb3$ICunitID)])\ncombScaled$scaledIndicator <- combScaled$value/combScaled$ref\ncombScaled <- dplyr::select(combScaled,\n                     -name,\n                     -value,\n                     -ref)\n\nassign(paste0(j, \"_bootstrapped_raw\"), comb)\nassign(paste0(j, \"_bootstrapped_scaled\"), combScaled)\n\n}\n\nfor(i in indicator){\n  temp <- get(paste0(i, \"_bootstrapped_raw\"))\n    temp <- get(paste0(i, \"_bootstrapped_scaled\"))\n\n  saveRDS(temp, paste0(\"data/\", i, \"_bootstrapped_raw.rds\"))\n    saveRDS(temp, paste0(\"data/\", i, \"_bootstrapped_scaled.rds\"))\n\n}"},{"path":"cross.html","id":"cross","chapter":"3 Time series","heading":"3 Time series","text":"","code":""},{"path":"cross.html","id":"raw-data","chapter":"3 Time series","heading":"3.1 Raw data","text":"","code":"\nlibrary(plotly)\n## TODO change to correct data source\npasserinesImport <- readRDS(paste0(here::here(), \"/data/passerinesImport.rds\"))\n\ndat=passerinesImport$indicatorObservations$indicatorValues \n\ndat$yearName=as.numeric(dat$yearName) # convert character vector to numeric years\nsum_dat=dat %>% \n  group_by(ICunitName, yearName) %>% \n  summarise(mnExpected=mean(expectedValue, na.rm=TRUE),\n            mnUpper=mean(upperQuantile, na.rm=TRUE),\n            mnLower=mean(lowerQuantile, na.rm=TRUE)) # summerise the data to mean values\n\np=sum_dat %>% \n  ggplot(aes(as.numeric(yearName), mnExpected, col=ICunitName))+\n  geom_line()+\n  geom_pointrange(aes(x=as.numeric(yearName), y=mnExpected, ymin=mnLower, ymax=mnUpper))+\n  geom_point(data=dat, aes(as.numeric(yearName), expectedValue, alpha=0.2))+\n  labs(x=\"year\", y=\"Expected value\")+\n  theme_classic()+\n  theme(text = element_text(colour = \"#A0A0A3\"), \n        title = element_text(colour = \"#FFFFFF\"), \naxis.title.x = element_text(colour = \"#A0A0A3\"), \naxis.title.y = element_text(colour = \"#A0A0A3\"), \npanel.grid.major.y = element_line(colour = \"#707073\", size=0.2)) # replace this with the correct theme\n\np2=ggplotly(p)\np2 %>% layout(\n  updatemenus = list(\n    list(\n      type = \"list\",\n      label = 'Category',\n      buttons = list(\n        list(method = \"restyle\",\n             args = list('visible', c(TRUE, FALSE, FALSE)),\n             label = \"Nord-Norge\"),\n        list(method = \"restyle\",\n             args = list('visible', c(FALSE, TRUE, FALSE)),\n             label = \"Norge\"),\n        list(method = \"restyle\",\n             args = list('visible', c(FALSE, FALSE, TRUE)),\n             label = \"Sør-Norge\")\n      )\n    )\n  )\n) # Add drop down menus for the data"},{"path":"cross.html","id":"scaled-data","chapter":"3 Time series","heading":"3.2 Scaled data","text":"","code":""},{"path":"maps.html","id":"maps","chapter":"4 Maps","heading":"4 Maps","text":"","code":""},{"path":"maps.html","id":"raw-data-1","chapter":"4 Maps","heading":"4.1 Raw data","text":"","code":""},{"path":"maps.html","id":"scaled-data-1","chapter":"4 Maps","heading":"4.2 Scaled data","text":"","code":""},{"path":"maps.html","id":"jerv","chapter":"4 Maps","heading":"4.2.1 Jerv","text":"","code":""},{"path":"maps.html","id":"prepare-ni-data","chapter":"4 Maps","heading":"4.2.1.1 Prepare NI data","text":"jerv (wolverine) data downloaded using R/singleIndicator.R script importDatasetApi() function,, subsequently assembleNiObject() function, now can simply import .data file contains raw data form expected values BSunits (municipalities). actually want keep original geometeris eight rovviltregioner, need focus ICunits instead.data also contains upper lower quantiles, can also get full probability distribution sample get standard deviations.\nalso probability functions can sample :reason extected values far mean distributions. exercise , get problem . think difference use eco = NULL time, importDatasetApi(), cause output somehow split forest alpine ecosystems. ignore example.can also get reference values way, divide one get scaled valuesThen create data frame mean indicator values SD.special case maybe, sd often larger mean.Btw, use inbuilt NIcalc functions get indicator value, like , aggregate regions, want keep original geometry.\nFigure 4.1: scaled indicator values wolverine across Norway.\n","code":"\njerv <- readRDS(\"data/Jerv_assemebled.rds\")\npar(mar=c(9,5,1,1))\nbarplot(jerv$indicatorValues$`2019`$expectedValue,\n        names.arg = jerv$indicatorValues$`2019`$ICunitName, \n        las=2,\n        ylab = \"Estimated number of\\nwolverine in 2019\")\n# bruker tradOb siden custumDist er NA. Dette er ikke en generisk løsning. \nobstype <- rep(\"tradObs\", nrow(jerv$indicatorValues$'2019'))\n\n#myYears <- as.character(c(1990,2000,2010,2014,2019))\nmyYears <- as.character(c(2019))\n\nfor(i in 1:length(myYears)){\n# print(i)\n\nmyMat <- NIcalc::sampleObsMat(\n  ICunitId           = jerv$indicatorValues[[i]]$ICunitId, \n  value              = jerv$indicatorValues[[i]]$expectedValue,\n  distrib            = jerv$indicatorValues[[i]]$distributionFamilyName,\n  mu                 = jerv$indicatorValues[[i]]$distParameter1,\n  sig                = jerv$indicatorValues[[i]]$distParameter2,\n  customDistribution = jerv$indicatorValues[[i]]$customDistribution,\n          obsType = obstype,\n          nsim = 1000\n          \n)\nassign(paste0(\"myMat\", myYears[i]), myMat)\n}\n#> Warning: replacing previous import 'distr::plot' by\n#> 'graphics::plot' when loading 'NIcalc'\n\npar(mfrow = c(1,2))\nhist(myMat2019[1,], main = \"Rovviltregion 1\", xlab = \"\")\nhist(myMat2019[8,], main = \"Rovviltregion 8\", xlab = \"\")\nmyMatr <- NIcalc::sampleObsMat(\n            jerv$referenceValues$ICunitId, \n            jerv$referenceValues$expectedValue,\n            jerv$referenceValues$distributionFamilyName,\n            mu = jerv$referenceValues$distParameter1,\n            sig = jerv$referenceValues$distParameter2,\n            customDistribution = jerv$referenceValues$customDistribution,\n            obsType = obstype,\n            nsim =1000\n        )\n\ntemp <- colSums(myMat2019)/colSums(myMatr)\nhist(temp)\nlibrary(matrixStats)\n#> Warning: package 'matrixStats' was built under R version\n#> 4.1.3\njerv_tbl <- data.frame(\"raw2019\" = round(rowMeans(myMat2019), 2),\n                       \"sd2019\"  = round(matrixStats::rowSds(myMat2019), 2),\n                       \"ref\"     = round(rowMeans(myMatr), 2))\njerv_tbl$scaled <- round(jerv_tbl$raw2019/jerv_tbl$ref, 2)\njerv_tbl$cv <- round(jerv_tbl$sd2019/jerv_tbl$raw2019, 2)\njerv_tbl$region <- jerv$indicatorValues$`2019`$ICunitName\nDT::datatable(jerv_tbl)\njervComp <- NIcalc::calculateIndex(\n  x       = jerv,\n  nsim     = 1000,\n  awBSunit = \"terrestrialArea\",\n  fids     = F,    # should fidelities be ignored in \n                   # the calculation of Wi?\n  tgroups  = F, # should grouping of indicators \n                   # into trophic and key indicator \n                   # groups be ignored\n  keys     = \"specialWeight\", #\"ignore\",\n)\n#> Indices for NIunits 'wholeArea', 'E', 'S', 'W', 'C', 'N'\n#> and years '1990', '2000', '2010', '2014', '2019' will be calculated.\n#> The 30 index distributions will each be based on  1000 simulations.\n#> There are 8 ICunits with observations in data set 'jerv'.\n#> \n#> Calculating weights that are the same for all years .....\n#> \n#> Sampling reference values .....\n#> \n#> Sampling and scaling indicator observations from  1990 .....\n#> \n#> Sampling and scaling indicator observations from  2000 .....\n#> \n#> Sampling and scaling indicator observations from  2010 .....\n#> \n#> Sampling and scaling indicator observations from  2014 .....\n#> \n#> Sampling and scaling indicator observations from  2019 .....\nplot(jervComp$wholeArea)"},{"path":"maps.html","id":"get-geometries","chapter":"4 Maps","heading":"4.2.1.2 Get geometries","text":"can get spatial geometries associated data. called rovviltregioner. eight . actually linked BS-units (municipalites), don’t want plot outlines municipalities.Add text got json file converted shape fileClip outline Norway make look pretty","code":"\npath <- \"P:/41201612_naturindeks_2021_2023_database_og_innsynslosning/Pilot_Forbedring_Innsynsløsning/Shapefiles/Jerv\"\nlibrary(sf)\n#> Linking to GEOS 3.9.1, GDAL 3.2.1, PROJ 7.2.1; sf_use_s2() is TRUE\nrov <- sf::read_sf(path)\nrov <- sf::st_make_valid(rov)\nrov <- rov[rov$area!=\"DEF jerv\",]\npath <- \"data/outlineOfNorway_EPSG25833.shp\"\nnor <- sf::read_sf(path)\nnor <- st_transform(nor, crs=st_crs(rov))\nrov <- st_intersection(rov, nor)\n#> Warning: attribute variables are assumed to be spatially\n#> constant throughout all geometries"},{"path":"maps.html","id":"link-data-and-geometries","chapter":"4 Maps","heading":"4.2.1.3 Link data and geometries","text":"","code":"\nrov$scaledIndicator <- jerv_tbl$scaled[match(rov$area, jerv_tbl$region)]\nrov$cv <- jerv_tbl$cv[match(rov$area, jerv_tbl$region)]\nrov$raw <- jerv_tbl$raw2019[match(rov$area, jerv_tbl$region)]\nlibrary(tmap)\none <- tm_shape(rov)+\n  tm_polygons(col=\"scaledIndicator\", \n              border.col = \"white\")\n\ntwo <- tm_shape(rov)+\n  tm_polygons(col=\"cv\", \n              border.col = \"white\")\n\nthree <- tm_shape(rov)+\n  tm_polygons(col=\"raw\", \n              border.col = \"white\")\n\n\ntmap_arrange(one, two, \n             widths = c(.75, .25),\n             heights = c(1, 0.5))\n#> Legend labels were too wide. The labels have been resized to 0.52, 0.52, 0.52, 0.52, 0.52, 0.52, 0.52. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger."},{"path":"other-figures.html","id":"other-figures","chapter":"5 Other figures","heading":"5 Other figures","text":"","code":""},{"path":"other-figures.html","id":"wordcloud-figures","chapter":"5 Other figures","heading":"5.1 Wordcloud figures","text":"following wordcloud figures show pressure factors indicator, color saturation text size represent importance pressure factor. Small text size low saturation means low importance, large text size represent pressure factors high importance indicator.","code":"\n\nlibrary(wordcloud)\nlibrary(NIcalc)\nlibrary(wordcloud2)\nlibrary(RColorBrewer)\nlibrary(readxl)\nlibrary(dplyr)\nlibrary(tm)\n# Load dataset\npressure = read_excel(\"P:/41201612_naturindeks_2021_2023_database_og_innsynslosning/Pilot_Forbedring_Innsynsløsning/R/Indikator_paavirkning.xlsx\")\n\n# Filter for species of interest\npressure = pressure %>% filter(navn_norsk == \"Elg\" | navn_norsk == \"Dikesoldogg\" | navn_norsk == \"Havørn\" | navn_norsk == \"Lange\" | navn_norsk == \"Jerv\" | navn_norsk == \"Lomvi\") # NB - Jerv was not included in the provided excel file\npressure = arrange(pressure, by = navn_norsk)\npressure = pressure %>% rename(PressureFactor = Paavirkningsfaktor, PressureValue = FK_PaavirkningsverdiID)\n\n# Remove all instances of \"Ikke rel/ukjent\" category\" and increase the value of pressure factors for better contrast in wordcloud figures\npressure = pressure %>% filter(PressureValue != 7) %>% mutate(PressureValue = PressureValue*2) \n\n# Create separate datasets for the different species\ndikesoldogg = pressure %>% filter(navn_norsk == \"Dikesoldogg\") %>% dplyr::select(PressureFactor, PressureValue)\n\nelg = pressure %>% filter(navn_norsk == \"Elg\") %>% dplyr::select(PressureFactor, PressureValue)\n\nhavørn = pressure %>% filter(navn_norsk == \"Havørn\") %>% dplyr::select(PressureFactor, PressureValue)\n\nlange = pressure %>% filter(navn_norsk == \"Lange\") %>% dplyr::select(PressureFactor, PressureValue)\n\nlomvi = pressure %>% filter(navn_norsk == \"Lomvi\") %>% dplyr::select(PressureFactor, PressureValue)\n\n# Create a custom color gradient (green in this case)\npressureColors = c(\"#bde4aa\", \"#addb9d\", \"#9cd28f\", \"#8cc982\", \"#7dc275\", \"#6cb967\", \"#5db15a\", \"#50a54e\", \"#479845\", \"#3f8c3b\", \"#367e31\", \"#2e7228\", \"#25661f\") "},{"path":"other-figures.html","id":"the-most-important-pressure-factors-for-dikesoldogg-oblong-leaved-sundew","chapter":"5 Other figures","heading":"5.2 The most important pressure factors for dikesoldogg (oblong-leaved sundew)","text":"","code":"\n\n# Dikesoldogg\nwordcloud(words = dikesoldogg$PressureFactor, freq = dikesoldogg$PressureValue, min.freq = 1, max.words = 200, random.order = FALSE, rot.per = 0.35, colors = pressureColors, scale = c(1.5, 0.5)) # use rot.per to set the percentage of words that are at a 90 degree angle"},{"path":"other-figures.html","id":"the-most-important-pressure-factors-for-elg-moose","chapter":"5 Other figures","heading":"5.3 The most important pressure factors for elg (Moose)","text":"","code":"\n\nwordcloud(words = elg$PressureFactor, freq = elg$PressureValue, min.freq = 1, max.words = 200, random.order = FALSE, rot.per = 0.35, colors = pressureColors, scale = c(1.5, 0.5))"},{"path":"other-figures.html","id":"the-most-important-pressure-factors-for-havørn-white-tailed-eagle","chapter":"5 Other figures","heading":"5.4 The most important pressure factors for havørn (White-tailed eagle)","text":"","code":"\nwordcloud(words = havørn$PressureFactor, freq = havørn$PressureValue, min.freq = 1, max.words = 200, random.order = FALSE, rot.per = 0.35, colors = pressureColors, scale = c(1.5, 0.5))"},{"path":"other-figures.html","id":"the-most-important-pressure-factors-for-lange-common-ling","chapter":"5 Other figures","heading":"5.5 The most important pressure factors for Lange (Common ling)","text":"","code":"\n\nwordcloud(words = lange$PressureFactor, freq = lange$PressureValue, min.freq = 1, max.words = 200, random.order = FALSE, rot.per = 0.35, colors = pressureColors, scale = c(1.5, 0.5))"},{"path":"other-figures.html","id":"the-most-important-pressure-factors-for-lomvi-common-guillemot","chapter":"5 Other figures","heading":"5.6 The most important pressure factors for Lomvi (common guillemot)","text":"","code":"\n\nwordcloud(words = lomvi$PressureFactor, freq = lomvi$PressureValue, min.freq = 1, max.words = 200, random.order = FALSE, rot.per = 0.35, colors = pressureColors, scale = c(1.5, 0.5))"},{"path":"other-figures.html","id":"data-type","chapter":"5 Other figures","heading":"5.7 Data type","text":"","code":"\nsource(\"R/colorPalettes.R\")\n#Elg datatyper\ndata <- data.frame(\n  category=c(\"Ekspert\", \n             \"Modeller\", \n             \"Overvåkning\"),\n  count=c(4.9, 95.1, 0)\n)\n\n# load library\nlibrary(tidyverse)\n#> -- Attaching packages ------------------- tidyverse 1.3.1 --\n#> v ggplot2 3.3.5     v purrr   0.3.4\n#> v tibble  3.1.6     v stringr 1.4.0\n#> v tidyr   1.2.0     v forcats 0.5.1\n#> v readr   2.1.2\n#> -- Conflicts ---------------------- tidyverse_conflicts() --\n#> x ggplot2::annotate() masks NLP::annotate()\n#> x dplyr::filter()     masks stats::filter()\n#> x dplyr::lag()        masks stats::lag()\n# Compute percentages\ndata$fraction <- data$count / sum(data$count)\n\n# Compute the cumulative percentages (top of each rectangle)\ndata$ymax <- cumsum(data$fraction)\n\n# Compute the bottom of each rectangle\ndata$ymin <- c(0, head(data$ymax, n=-1))\n\n# Compute label position\ndata$labelPosition <- (data$ymax + data$ymin) / 2\ndata$labelPosition[3]<-0.8\n# Compute a good label\ndata$label <- paste0(data$category, \"\\n \", data$count, \" %\")\nlibrary(ggrepel)\n#> Warning: package 'ggrepel' was built under R version 4.1.3\n# Make the plot\nggplot(data, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=category)) +\n  geom_rect() +\n  geom_text(x=2, aes(y=labelPosition, label=label, color=category), size=2.5) + # x here controls label position (inner / outer)\n  scale_fill_NIviz_d(\"IndMap_cols\") +\n  scale_colour_NIviz_d(\"IndMap_cols\") +\n  coord_polar(theta=\"y\") +\n  xlim(c(-1, 4)) +\n  theme_void() +\n  theme(legend.position = \"none\")"}]
