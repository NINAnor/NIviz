[{"path":"index.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"","code":""},{"path":"downloading-and-prepaering-example-data.html","id":"downloading-and-prepaering-example-data","chapter":"2 Downloading and prepaering example data","heading":"2 Downloading and prepaering example data","text":"","code":""},{"path":"cross.html","id":"cross","chapter":"3 Time series","heading":"3 Time series","text":"","code":""},{"path":"cross.html","id":"raw-data","chapter":"3 Time series","heading":"3.1 Raw data","text":"","code":""},{"path":"cross.html","id":"scaled-data","chapter":"3 Time series","heading":"3.2 Scaled data","text":"","code":""},{"path":"maps.html","id":"maps","chapter":"4 Maps","heading":"4 Maps","text":"","code":""},{"path":"maps.html","id":"raw-data-1","chapter":"4 Maps","heading":"4.1 Raw data","text":"","code":""},{"path":"maps.html","id":"scaled-data-1","chapter":"4 Maps","heading":"4.2 Scaled data","text":"","code":""},{"path":"maps.html","id":"jerv","chapter":"4 Maps","heading":"4.2.1 Jerv","text":"","code":""},{"path":"maps.html","id":"prepare-ni-data","chapter":"4 Maps","heading":"4.2.1.1 Prepare NI data","text":"jerv (wolverine) data downloaded using R/singleIndicator.R script importDatasetApi() function,, subsequently assembleNiObject() function, now can simply import .data file contains raw data form expected values BSunits (municipalities). actually want keep original geometeris eight rovviltregioner, need focus ICunits instead.data also contains upper lower quantiles, can also get full probability distribution sample get standard deviations.\nalso probability functions can sample :reason extected values far mean distributions. exercise , get problem . think difference use eco = NULL time, importDatasetApi(), cause output somehow split forest alpine ecosystems. ignore example.can also get reference values way, divide one get scaled valuesThen create data frame mean indicator values SD.special case maybe, sd often larger mean.Btw, use inbuilt NIcalc functions get indicator value, like , aggregate regions, want keep original geometry.\nFigure 4.1: scaled indicator values wolverine across Norway.\n","code":"\njerv <- readRDS(\"data/jerv_assemble.rds\")\npar(mar=c(9,5,1,1))\nbarplot(jerv$indicatorValues$`2019`$expectedValue,\n        names.arg = jerv$indicatorValues$`2019`$ICunitName, \n        las=2,\n        ylab = \"Estimated number of\\nwolverine in 2019\")\n# bruker tradOb siden custumDist er NA. Dette er ikke en generisk løsning. \nobstype <- rep(\"tradObs\", nrow(jerv$indicatorValues$'2019'))\n\n#myYears <- as.character(c(1990,2000,2010,2014,2019))\nmyYears <- as.character(c(2019))\n\nfor(i in 1:length(myYears)){\n# print(i)\n\nmyMat <- NIcalc::sampleObsMat(\n  ICunitId           = jerv$indicatorValues[[i]]$ICunitId, \n  value              = jerv$indicatorValues[[i]]$expectedValue,\n  distrib            = jerv$indicatorValues[[i]]$distributionFamilyName,\n  mu                 = jerv$indicatorValues[[i]]$distParameter1,\n  sig                = jerv$indicatorValues[[i]]$distParameter2,\n  customDistribution = jerv$indicatorValues[[i]]$customDistribution,\n          obsType = obstype,\n          nsim = 1000\n          \n)\nassign(paste0(\"myMat\", myYears[i]), myMat)\n}\n#> Warning: replacing previous import 'distr::plot' by\n#> 'graphics::plot' when loading 'NIcalc'\n\npar(mfrow = c(1,2))\nhist(myMat2019[1,], main = \"Rovviltregion 1\", xlab = \"\")\nhist(myMat2019[8,], main = \"Rovviltregion 8\", xlab = \"\")\nmyMatr <- NIcalc::sampleObsMat(\n            jerv$referenceValues$ICunitId, \n            jerv$referenceValues$expectedValue,\n            jerv$referenceValues$distributionFamilyName,\n            mu = jerv$referenceValues$distParameter1,\n            sig = jerv$referenceValues$distParameter2,\n            customDistribution = jerv$referenceValues$customDistribution,\n            obsType = obstype,\n            nsim =1000\n        )\n\ntemp <- colSums(myMat2019)/colSums(myMatr)\nhist(temp)\nlibrary(matrixStats)\n#> Warning: package 'matrixStats' was built under R version\n#> 4.1.3\njerv_tbl <- data.frame(\"raw2019\" = round(rowMeans(myMat2019), 2),\n                       \"sd2019\"  = round(matrixStats::rowSds(myMat2019), 2),\n                       \"ref\"     = round(rowMeans(myMatr), 2))\njerv_tbl$scaled <- round(jerv_tbl$raw2019/jerv_tbl$ref, 2)\njerv_tbl$cv <- round(jerv_tbl$sd2019/jerv_tbl$raw2019, 2)\njerv_tbl$region <- jerv$indicatorValues$`2019`$ICunitName\nDT::datatable(jerv_tbl)\njervComp <- NIcalc::calculateIndex(\n  x       = jerv,\n  nsim     = 1000,\n  awBSunit = \"terrestrialArea\",\n  fids     = F,    # should fidelities be ignored in \n                   # the calculation of Wi?\n  tgroups  = F, # should grouping of indicators \n                   # into trophic and key indicator \n                   # groups be ignored\n  keys     = \"specialWeight\", #\"ignore\",\n)\n#> Indices for NIunits 'wholeArea', 'E', 'S', 'W', 'C', 'N'\n#> and years '1990', '2000', '2010', '2014', '2019' will be calculated.\n#> The 30 index distributions will each be based on  1000 simulations.\n#> There are 8 ICunits with observations in data set 'jerv'.\n#> \n#> Calculating weights that are the same for all years .....\n#> \n#> Sampling reference values .....\n#> \n#> Sampling and scaling indicator observations from  1990 .....\n#> \n#> Sampling and scaling indicator observations from  2000 .....\n#> \n#> Sampling and scaling indicator observations from  2010 .....\n#> \n#> Sampling and scaling indicator observations from  2014 .....\n#> \n#> Sampling and scaling indicator observations from  2019 .....\nplot(jervComp$wholeArea)"},{"path":"maps.html","id":"get-geometries","chapter":"4 Maps","heading":"4.2.1.2 Get geometries","text":"can get spatial geometries associated data. called rovviltregioner. eight . actually linked BS-units (municipalites), don’t want plot outlines municipalities.Add text got json file converted shape fileClip outline Norway make look pretty","code":"\npath <- \"P:/41201612_naturindeks_2021_2023_database_og_innsynslosning/Pilot_Forbedring_Innsynsløsning/Shapefiles/Jerv\"\nlibrary(sf)\n#> Linking to GEOS 3.9.1, GDAL 3.2.1, PROJ 7.2.1; sf_use_s2() is TRUE\nrov <- sf::read_sf(path)\nrov <- sf::st_make_valid(rov)\nrov <- rov[rov$area!=\"DEF jerv\",]\npath <- \"data/outlineOfNorway_EPSG25833.shp\"\nnor <- sf::read_sf(path)\nnor <- st_transform(nor, crs=st_crs(rov))\nrov <- st_intersection(rov, nor)\n#> Warning: attribute variables are assumed to be spatially\n#> constant throughout all geometries"},{"path":"maps.html","id":"link-data-and-geometries","chapter":"4 Maps","heading":"4.2.1.3 Link data and geometries","text":"","code":"\nrov$scaledIndicator <- jerv_tbl$scaled[match(rov$area, jerv_tbl$region)]\nrov$cv <- jerv_tbl$cv[match(rov$area, jerv_tbl$region)]\nrov$raw <- jerv_tbl$raw2019[match(rov$area, jerv_tbl$region)]\nlibrary(tmap)\none <- tm_shape(rov)+\n  tm_polygons(col=\"scaledIndicator\", \n              border.col = \"white\")\n\ntwo <- tm_shape(rov)+\n  tm_polygons(col=\"cv\", \n              border.col = \"white\")\n\nthree <- tm_shape(rov)+\n  tm_polygons(col=\"raw\", \n              border.col = \"white\")\n\n\ntmap_arrange(one, two, \n             widths = c(.75, .25),\n             heights = c(1, 0.5))\n#> Legend labels were too wide. The labels have been resized to 0.52, 0.52, 0.52, 0.52, 0.52, 0.52, 0.52. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger."},{"path":"other-figures.html","id":"other-figures","chapter":"5 Other figures","heading":"5 Other figures","text":"","code":""}]
