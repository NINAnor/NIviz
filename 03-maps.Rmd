# Maps


## Raw data

## Scaled data

### Jerv


#### Prepare NI data

The jerv (wolverine) data was downloaded using the `R/singleIndicator.R` script and the importDatasetApi() function,, and subsequently the assembleNiObject() function, so now I can simply import it.
```{r, include=F, eval=FALSE}
# RETRIEVE DATA FROM DATABASE #
#-----------------------------#'
indicator <- c("Dikesoldogg")
indicator <- c("Jerv")

myUsername <- "anders.kolstad@nina.no"
myPassword <- ""

indicatorImport <- importDatasetApi(username = myUsername,
                                    password = myPassword,
                                    eco = NULL,
                                    indic = indicator,
                                    year = c("1990","2000","2010","2014","2019"),
                                    norwegian = TRUE,
                                    refYearCode = 0)
#getwd()
#saveRDS(indicatorImport, "data/jerv.rds")


# ASSEMBLE 
# Spesify all of Norway incl the five regions, som NIunits:
myNIunits <- c(allArea = T, parts = T, counties = F)

# Include all BSunits (kommuner):
myPartOfTotal <- 0

assemeble <- NIcalc::assembleNiObject(
  inputData = indicatorImport,
  predefNIunits = myNIunits, 
  partOfTotal = myPartOfTotal, 
  indexType = "thematic",
  part = "ecosystem",
  total = "terrestrial")  


#saveRDS(assemeble, "data/jerv_assemble.rds")    
```


```{r}
jerv <- readRDS("data/jerv_assemble.rds")
```


This data file contains the raw data in the form of expected values for each BSunits (municipalities). But we actually want to keep the original geometeris of the eight rovviltregioner, and so we need to focus in the ICunits instead.
```{r}
par(mar=c(9,5,1,1))
barplot(jerv$indicatorValues$`2019`$expectedValue,
        names.arg = jerv$indicatorValues$`2019`$ICunitName, 
        las=2,
        ylab = "Estimated number of\nwolverine in 2019")
```

The data also contains upper and lower quantiles, but we can also get the full probability distribution and sample from it to get standard deviations. 
but also as probability functions that we can sample from:
```{r}
# bruker tradOb siden custumDist er NA. Dette er ikke en generisk løsning. 
obstype <- rep("tradObs", nrow(jerv$indicatorValues$'2019'))

#myYears <- as.character(c(1990,2000,2010,2014,2019))
myYears <- as.character(c(2019))

for(i in 1:length(myYears)){
# print(i)

myMat <- NIcalc::sampleObsMat(
  ICunitId           = jerv$indicatorValues[[i]]$ICunitId, 
  value              = jerv$indicatorValues[[i]]$expectedValue,
  distrib            = jerv$indicatorValues[[i]]$distributionFamilyName,
  mu                 = jerv$indicatorValues[[i]]$distParameter1,
  sig                = jerv$indicatorValues[[i]]$distParameter2,
  customDistribution = jerv$indicatorValues[[i]]$customDistribution,
          obsType = obstype,
          nsim = 1000
          
)
assign(paste0("myMat", myYears[i]), myMat)
}

par(mfrow = c(1,2))
hist(myMat2019[1,], main = "Rovviltregion 1", xlab = "")
hist(myMat2019[8,], main = "Rovviltregion 8", xlab = "")

```

For some reason the extected values are far from the mean of these distributions. I did this exercise [once before](https://ninanor.github.io/IBECA/jerv.html), and did not get this problem then. I think the difference is that I use eco = NULL this time, in the `importDatasetApi()`, and this cause the output to somehow split into forest and alpine ecosystems. I will ignore this here for this example.

I can also get the reference values in the same way, and then divide one by the other to get scaled values
```{r}
myMatr <- NIcalc::sampleObsMat(
            jerv$referenceValues$ICunitId, 
            jerv$referenceValues$expectedValue,
            jerv$referenceValues$distributionFamilyName,
            mu = jerv$referenceValues$distParameter1,
            sig = jerv$referenceValues$distParameter2,
            customDistribution = jerv$referenceValues$customDistribution,
            obsType = obstype,
            nsim =1000
        )

temp <- colSums(myMat2019)/colSums(myMatr)
hist(temp)
```

Then I will create a data frame with the mean indicator values and the SD.
```{r}
library(matrixStats)
jerv_tbl <- data.frame("raw2019" = round(rowMeans(myMat2019), 2),
                       "sd2019"  = round(matrixStats::rowSds(myMat2019), 2),
                       "ref"     = round(rowMeans(myMatr), 2))
jerv_tbl$scaled <- round(jerv_tbl$raw2019/jerv_tbl$ref, 2)
jerv_tbl$cv <- round(jerv_tbl$sd2019/jerv_tbl$raw2019, 2)
jerv_tbl$region <- jerv$indicatorValues$`2019`$ICunitName
DT::datatable(jerv_tbl)
```
This is a special case maybe, because the sd is often larger than the mean.

Btw, we could use inbuilt NIcalc functions to get the indicator value, like I do below, but that will aggregate to regions, and we want to keep the original geometry.
```{r, fig.cap="The scaled indicator values for wolverine across Norway."}
jervComp <- NIcalc::calculateIndex(
  x       = jerv,
  nsim     = 1000,
  awBSunit = "terrestrialArea",
  fids     = F,    # should fidelities be ignored in 
                   # the calculation of Wi?
  tgroups  = F, # should grouping of indicators 
                   # into trophic and key indicator 
                   # groups be ignored
  keys     = "specialWeight", #"ignore",
)
plot(jervComp$wholeArea)
```



#### Get geometries

Then I can get the spatial geometries associated with the data. There are the so called rovviltregioner. There are eight of them. They are actually linked to the BS-units (municipalites), but we don't want to plot the outlines of the municipalities.

*Add text about how we got the json file and converted it to a shape file*

```{r}
path <- "P:/41201612_naturindeks_2021_2023_database_og_innsynslosning/Pilot_Forbedring_Innsynsløsning/Shapefiles/Jerv"
```

```{r}
library(sf)
rov <- sf::read_sf(path)
rov <- sf::st_make_valid(rov)
rov <- rov[rov$area!="DEF jerv",]
```

Clip it against the outline of Norway to make it look more pretty
```{r}
path <- "data/outlineOfNorway_EPSG25833.shp"
nor <- sf::read_sf(path)
nor <- st_transform(nor, crs=st_crs(rov))
```

```{r}
rov <- st_intersection(rov, nor)
```




#### Link data and geometries

```{r}
rov$scaledIndicator <- jerv_tbl$scaled[match(rov$area, jerv_tbl$region)]
rov$cv <- jerv_tbl$cv[match(rov$area, jerv_tbl$region)]
rov$raw <- jerv_tbl$raw2019[match(rov$area, jerv_tbl$region)]

```



```{r}
library(tmap)
one <- tm_shape(rov)+
  tm_polygons(col="scaledIndicator", 
              border.col = "white")

two <- tm_shape(rov)+
  tm_polygons(col="cv", 
              border.col = "white")

three <- tm_shape(rov)+
  tm_polygons(col="raw", 
              border.col = "white")


tmap_arrange(one, two, 
             widths = c(.75, .25),
             heights = c(1, 0.5))
```

